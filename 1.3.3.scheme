(define (search f neg-point pos-point)
  (let ((midpoint (average neg-point pos-point)))
      (if (close-enought? neg-point pos-point)
          midpoint
          (let ((v (f midpoint)))
              (cond ((positive? v) (search f neg-point midpoint))
                    ((negative? v) (search f midpoint pos-point))
                    (else midpoint))))))

(define (average x y)
  (/ (+ x y)
     2))

(define (close-enought? x y)
  (< (abs (- x y))
     0.001))

(search (lambda (x) (- x 1)) -1 3.5) ; expected 1.0

(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
      (cond ((and (negative? a-value) (positive? b-value))
            (search f a b))
            ((and (positive? a-value) (negative? b-value))
            (search f b a))
            (else (error "Values are not of opposite sign" a-value b-value))))) ; yes I think that you are more interested in (f a) (f b)

(half-interval-method sin 2.0 4.0) ;Value: 3.14111328125
(half-interval-method sin 4.0 2.0) ;Value: 3.14111328125
; check for error (half-interval-method sin 1.0 2.0) ;Value: 3.14111328125

(half-interval-method (lambda (x) (- (* x x x) (* 2 x) 3))
                      1.0
                      2.0) ; 1.89306640625

(define tolerance 0.00001)

(define (close-enought? x y)
    (< (abs (- x y))
       tolerance)); will be used later

(define (fixed-point f first-guess)

  (define (try guess)
    (newline)
    (display guess)
    (let ((next (f guess)))
        (if (close-enought? next guess)
            next
            (try next))))
  (try first-guess))

(fixed-point cos 1.0)

(fixed-point (lambda (y) (+ (sin y) (cos y)))
             1.0)

(define (sqrt x)
  (fixed-point (lambda (y) (average y (/ x y)))
               1.0))

(sqrt 4.0)
(sqrt 2.0)

; excercise 1.35

(define golden-ratio
  (fixed-point (lambda (x) (+ 1 (/ 1 x)))
            1.0))

golden-ratio ;1.6180327868852458

; excercise 1.36

(define right-side 1000)
(fixed-point (lambda (x) (/ (log right-side)
                            (log x)))
             2.0)

; 34 steps ~= 999.991
; mid-point
(fixed-point (lambda (x) (average (/ (log right-side)
                                     (log x))
                                  x))
             2.0)
;9 steps ~= 1000.004

; excercise 1.37

(define (cont-fract n d k)
  (define (iter part left)
    (if (= left 0)
        part
        (iter (/ (n left)
                 (+ part (d left)))
              (- left 1))))
  (iter 0 k))



(define tolerance 0.00001)

(define (find-cont-fract-term f expected k)
  (if (close-enought? (f k)
                      expected)
      k
      (find-cont-fract-term f expected (+ k 1))))

(define (golden-ratio-approximation k)
  (/ 1.0 (cont-fract (lambda (i) 1.0)
                     (lambda (i) 1.0)
                     k)))

(find-cont-fract-term (lambda (k) (golden-ratio-approximation k))
        1.61803398875
        0) ; 12

(golden-ratio-approximation 12) ; ~= 1.618

; excercise 1.38

(define (e-approximation k)
  (+ 2
    (cont-fract (lambda (i) 1.0)
                (lambda (i)
                  (let ((j (+ i 1)))
                      (if (= (remainder j 3) 0)
                          (* (/ j 3) 2.0)
                          1.0)))
                k)))

(e-approximation 5)


(find-cont-fract-term (lambda (k) (e-approximation k))
        2.7182818284
        0) ; 8

(e-approximation 8) ; ~= 2.7183

(define (tan-cf x k)
  (- (cont-fract (lambda (i) (- (expt x i)))
                 (lambda (i) (- (* i 2) 1))
                 k)))

(abs (- (tan 1.0)
        (tan-cf 1.0 10))) ; 2e-16

